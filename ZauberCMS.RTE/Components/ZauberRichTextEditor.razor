@using ZauberCMS.RTE.Models
@implements IDisposable
@inject IZauberJsRuntime JsRuntime
@inject ToolbarDiscoveryService ToolbarDiscovery
@inject IJSRuntime JSRuntime

<link href="_content/ZauberCMS.RTE/css/fontawesome.min.css" rel="stylesheet" />
<link href="_content/ZauberCMS.RTE/css/zauber-panels.css" rel="stylesheet" />

<div class="zauber-rte @GetThemeClass()" id="@_editorId">
    <div class="rte-toolbar" role="toolbar" aria-label="Rich text editor toolbar">
        <ToolbarHost ToolbarLayout="Settings.ToolbarLayout"
                     Capabilities="Settings.Capabilities"
                     EditorState="_currentState"
                     OnItemExecuted="HandleToolbarCommandAsync" />
    </div>

    <div class="rte-editor-container">
        @if (_isSourceView)
        {
            <textarea class="rte-source-view"
                      @bind="_sourceViewContent"
                      @bind:event="oninput"
                      @onfocus="HandleFocusAsync"
                      @onblur="HandleBlurAsync"
                      spellcheck="false"
                      placeholder="Enter HTML source code..."
                      style="@GetEditorStyle()"
                      id="@(_editorId + "-source")">
            </textarea>
        }
        else
        {
            <div class="rte-content"
                 contenteditable="true"
                 @ref="_contentEditableRef"
                 @oninput="HandleInputAsync"
                 @onkeydown="HandleKeyDownAsync"
                 @onkeyup="HandleKeyUpAsync"
                 @onmouseup="HandleMouseUpAsync"
                 @onpaste="HandlePasteAsync"
                 @onfocus="HandleFocusAsync"
                 @onblur="HandleBlurAsync"
                 @onselectionchange="HandleSelectionChangeAsync"
                 @onfocusout="HandleFocusOutAsync"
                 spellcheck="false"
                 role="textbox"
                 aria-multiline="true"
                 aria-label="Rich text editor content"
                 style="@GetEditorStyle()"
                 id="@(_editorId + "-content")">
            </div>
            
            <div class="rte-editor-resize-handle" title="Drag to resize">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="12" height="12" fill="currentColor">
                    <path d="M32 288c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 288zm0-128c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 160z"/>
                </svg>
            </div>

            @if (Settings.Capabilities.EmbedsAndMedia)
            {
                <div class="rte-drop-zone" style="display: none;" @ondrop="HandleDropAsync" @ondragover="HandleDragOverAsync">
                    <span>Drop images here</span>
                </div>
            }
        }
    </div>

</div>

<SlideOutPanel @ref="_slideOutPanel" Api="@_editorApi" />

@code {
    private ElementReference _contentEditableRef;
    private SlideOutPanel? _slideOutPanel;
    private readonly string _editorId = $"zauber-rte-{Guid.NewGuid():N}";
    private readonly EditorState _currentState = new();
    private IEditorApi? _editorApi;
    private string? _currentHtml;
    private bool _isInitialized;
    private bool _isSourceView;
    private string? _sourceViewContent;
    private Theme _activeTheme = Theme.Auto;
    private bool _themeInitialized;

    // Parameters
    [Parameter] public string? Value { get; set; }
    [Parameter] public EventCallback<string?> ValueChanged { get; set; }
    [Parameter] public EventCallback<EditorChangeArgs> OnChange { get; set; }

    // Events
    [Parameter] public EventCallback<ZauberKeyboardEventArgs> OnKeyDown { get; set; }
    [Parameter] public EventCallback<SelectionChangedArgs> OnSelectionChanged { get; set; }
    [Parameter] public EventCallback<PasteArgs> OnPaste { get; set; }
    [Parameter] public EventCallback<ImageResizedArgs> OnImageResized { get; set; }
    [Parameter] public EventCallback<CommandExecutedArgs> OnCommandExecuted { get; set; }
    [Parameter] public EventCallback OnFocus { get; set; }
    [Parameter] public EventCallback OnBlur { get; set; }

    // Config
    [Parameter] public EditorSettings Settings { get; set; } = new();
    [Parameter] public Theme Theme { get; set; } = Theme.Auto;
    [Parameter] public bool ReadOnly { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await InitializeEditorAsync();
        }
    }

    private async Task WaitForJavaScriptAsync()
    {
        const int timeout = 5000; // 5 seconds timeout
        var startTime = DateTime.Now;

        while ((DateTime.Now - startTime).TotalMilliseconds < timeout)
        {
            var isLoaded = await JSRuntime.InvokeAsync<bool>("eval", "typeof window.ZauberRTE !== 'undefined'");
            if (isLoaded)
            {
                return;
            }
            await Task.Delay(50); // Wait 50ms before checking again
        }

        throw new TimeoutException("ZauberRTE JavaScript library failed to load within 5 seconds");
    }

    [JSInvokable]
    public async Task OnPasteCallbackAsync(string pastedContent)
    {
        try
        {
            // Clean the HTML using our policy
            var cleanedHtml = await JsRuntime.Clipboard.CleanHtmlAsync(pastedContent, Settings.HtmlPolicy);

            // Insert the cleaned HTML
            await JsRuntime.Clipboard.InsertCleanedHtmlAsync(_editorId, cleanedHtml);

            var pasteArgs = new PasteArgs
            {
                OriginalHtml = pastedContent,
                CleanedHtml = cleanedHtml
            };
            await OnPaste.InvokeAsync(pasteArgs);
        }
        catch
        {
        }
    }

    [JSInvokable]
    public async Task OnImageClickCallbackAsync(string imageId)
    {
        try
        {
            // Show resize handles for the clicked image
            await JsRuntime.Image.ShowResizeHandlesAsync(_editorId, imageId);
        }
        catch
        {
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Initialize theme once from parameter or settings
        if (!_themeInitialized)
        {
            _activeTheme = Theme != Theme.Auto 
                ? Theme 
                : Settings.DefaultTheme != Theme.Auto 
                    ? Settings.DefaultTheme 
                    : Theme.Auto;
            _themeInitialized = true;
        }

        // Set content if the value has changed
        if (Value != _currentHtml)
        {
            await SetContentAsync(Value);
        }
    }

    private async Task InitializeEditorAsync()
    {
        try
        {
            // Wait for JavaScript to load
            await WaitForJavaScriptAsync();

            // Register all keyboard shortcuts with JavaScript to prevent browser defaults
            var shortcuts = ToolbarDiscovery.GetAllItems().Values
                .Where(item => !string.IsNullOrEmpty(item.Shortcut))
                .Select(item => item.Shortcut)
                .ToArray();
            await JSRuntime.InvokeVoidAsync("ZauberRTE.shortcuts.registerShortcuts", _editorId, shortcuts);

            // Set up paste callback
            await JSRuntime.InvokeVoidAsync("ZauberRTE.clipboard.setPasteCallback",
                DotNetObjectReference.Create(this),
                nameof(OnPasteCallbackAsync));

            // Set up paste event listener
            await JSRuntime.InvokeVoidAsync("ZauberRTE.clipboard.setupPasteListener", _editorId);

            // Set up Enter key event listener with callback for content updates
            await JSRuntime.InvokeVoidAsync("ZauberRTE.selection.setupEnterKeyListener", 
                _editorId,
                DotNetObjectReference.Create(this),
                nameof(OnContentModifiedAsync));

            // Set up image focus/click event listeners for resize handles
            await JSRuntime.InvokeVoidAsync("ZauberRTE.image.setupImageListeners", _editorId,
                DotNetObjectReference.Create(this));

            // Set up resize handle for editor
            await JSRuntime.InvokeVoidAsync("ZauberRTE.resize.setupResizeHandle", _editorId);

            // Start observing mutations for change detection
            await JsRuntime.Mutation.StartObservingAsync(_editorId);

            // Create the editor API
            _editorApi = new EditorApi(this, JsRuntime, _editorId);

            // Set initial content
            if (!string.IsNullOrEmpty(_currentHtml))
            {
                await JsRuntime.Mutation.SetHtmlAsync(_editorId, _currentHtml);
            }
            else
            {
                // Ensure editor starts with proper paragraph structure
                await JsRuntime.Mutation.SetHtmlAsync(_editorId, "<p>&nbsp;</p>");
            }

            _isInitialized = true;
        }
        catch
        {
            // Log error but don't throw - editor should still work
        }
    }

    public async Task SetContentAsync(string? html)
    {
        if (string.IsNullOrEmpty(html))
        {
            _currentHtml = null;
            if (_isInitialized)
            {
                await JsRuntime.Mutation.SetHtmlAsync(_editorId, "");
            }
            return;
        }

        _currentHtml = html;
        if (_isInitialized)
        {
            await JsRuntime.Mutation.SetHtmlAsync(_editorId, html);
        }
        // If not initialized yet, the content will be set during initialization
    }

    private string GetThemeClass()
    {
        return _activeTheme switch
        {
            Theme.Light => "rte-theme-light",
            Theme.Dark => "rte-theme-dark",
            _ => "rte-theme-auto"
        };
    }

    private string GetEditorStyle()
    {
        var styles = new List<string>();

        if (!string.IsNullOrEmpty(Settings.Dimensions.Width))
            styles.Add($"width: {Settings.Dimensions.Width}");

        if (!string.IsNullOrEmpty(Settings.Dimensions.Height))
            styles.Add($"min-height: {Settings.Dimensions.Height ?? "200px"}");

        return string.Join("; ", styles);
    }

    private async Task HandleInputAsync()
    {
        await UpdateContentAsync();
    }

    private async Task HandleKeyDownAsync(KeyboardEventArgs args)
    {
        var keyboardArgs = new ZauberKeyboardEventArgs
        {
            Key = args.Key,
            CtrlKey = args.CtrlKey,
            ShiftKey = args.ShiftKey,
            AltKey = args.AltKey,
            MetaKey = args.MetaKey
        };

        // Note: Enter key is now handled entirely in JavaScript to prevent browser default behavior
        // Handle keyboard shortcuts
        if (await HandleKeyboardShortcutAsync(keyboardArgs))
        {
            keyboardArgs.Cancelled = true;
            // Prevent default behavior for handled shortcuts
        }

        await OnKeyDown.InvokeAsync(keyboardArgs);
    }

    private async Task HandleKeyUpAsync()
    {
        // Update toolbar state after key navigation (arrow keys, etc.)
        await UpdateStateAsync();
    }

    private async Task HandleMouseUpAsync()
    {
        // Update toolbar state after any mouse click/selection
        await UpdateStateAsync();
    }

    private async Task HandlePasteAsync()
    {
        // The paste handling is now done via JavaScript callback
        // This method is kept for the Blazor event binding but doesn't do anything
        // since we handle paste in the JS callback method
        await Task.CompletedTask;
    }

    private async Task HandleFocusAsync()
    {
        _currentState.HasFocus = true;
        await UpdateStateAsync();
        await OnFocus.InvokeAsync();
    }

    private async Task HandleBlurAsync()
    {
        _currentState.HasFocus = false;
        // Clear active marks when editor loses focus to prevent stale button states
        _currentState.ActiveMarks = [];
        _currentState.CurrentBlockType = "p";
        _currentState.CurrentHeadingLevel = 0;
        _currentState.HasSelection = false;
        await OnBlur.InvokeAsync();
    }

    private async Task HandleFocusOutAsync()
    {
        // Hide resize handles when focus leaves the editor
        await JsRuntime.Image.HideResizeHandlesAsync(_editorId);
    }

    private async Task HandleSelectionChangeAsync()
    {
        await UpdateStateAsync();

        var selectionArgs = new SelectionChangedArgs
        {
            Selection = await JsRuntime.Selection.GetSelectionAsync(_editorId),
            EditorState = _currentState
        };

        await OnSelectionChanged.InvokeAsync(selectionArgs);
    }

    private async Task HandleDropAsync()
    {
        // Handle file drops for images
        await Task.CompletedTask;
    }

    private async Task HandleDragOverAsync()
    {
        // Handle drag over for drop zone
        await Task.CompletedTask;
    }

    private async Task HandleToolbarCommandAsync(string commandId)
    {
        // Handle theme toggle specially
        if (commandId == "themeToggle")
        {
            _activeTheme = _activeTheme switch
            {
                Theme.Light => Theme.Dark,
                _ => Theme.Light
            };
            StateHasChanged();
            return;
        }

        var item = ToolbarDiscovery.GetItem(commandId);
        if (item == null) return;

        var api = new EditorApi(this, JsRuntime, _editorId);
        await item.ExecuteAsync(api);

        // Update content after toolbar command execution (force update for style changes)
        await UpdateContentAsync(forceUpdate: true);
        
        // Update editor state to reflect changes
        await UpdateStateAsync();
        StateHasChanged();

        var commandArgs = new CommandExecutedArgs
        {
            Command = commandId,
            Success = true
        };

        await OnCommandExecuted.InvokeAsync(commandArgs);
    }

    private async Task<bool> HandleKeyboardShortcutAsync(ZauberKeyboardEventArgs args)
    {
        // Check all registered toolbar items for matching shortcuts
        var allItems = ToolbarDiscovery.GetAllItems();
        
        foreach (var item in allItems.Values)
        {
            if (!string.IsNullOrEmpty(item.Shortcut) && 
                args.MatchesShortcut(item.Shortcut) && 
                item.IsEnabled(_currentState))
            {
                await HandleToolbarCommandAsync(item.Id);
                return true;
            }
        }

        // Additional fallback for Ctrl+Shift+Z as alternative redo shortcut
        if (args is { CtrlKey: true, ShiftKey: true, Key: "z" })
        {
            var redoItem = ToolbarDiscovery.GetItem("redo");
            if (redoItem?.IsEnabled(_currentState) == true)
            {
                await HandleToolbarCommandAsync("redo");
                return true;
            }
        }

        return false;
    }

    private async Task UpdateContentAsync(bool forceUpdate = false)
    {
        var html = await JsRuntime.Mutation.GetHtmlAsync(_editorId);
        if (forceUpdate || html != _currentHtml)
        {
            // Record the previous state for undo before changing
            if (_currentHtml != null && html != _currentHtml)
            {
                await JsRuntime.History.RecordStateAsync(_editorId);
            }

            _currentHtml = html;
            await ValueChanged.InvokeAsync(html);

            var changeArgs = new EditorChangeArgs
            {
                Html = html,
                Text = await JsRuntime.Mutation.GetHtmlAsync(_editorId) // This should get text content
            };

            await OnChange.InvokeAsync(changeArgs);
        }
    }

    private async Task UpdateStateAsync()
    {
        _currentState.ActiveMarks = await JsRuntime.Selection.GetActiveMarksAsync(_editorId);
        _currentState.CurrentBlockType = await JsRuntime.Selection.GetCurrentBlockTypeAsync(_editorId);
        _currentState.CurrentHeadingLevel = await JsRuntime.Selection.GetCurrentHeadingLevelAsync(_editorId);
        _currentState.HasSelection = (await JsRuntime.Selection.GetSelectionAsync(_editorId))?.IsCollapsed == false;
        _currentState.CanUndo = await JsRuntime.History.CanUndoAsync(_editorId);
        _currentState.CanRedo = await JsRuntime.History.CanRedoAsync(_editorId);

        // Update state with additional info as needed
    }

    // Public API methods for EditorApiImpl
    internal EditorState GetCurrentState() => _currentState;
    internal EditorSettings GetEditorSettings() => Settings;
    internal SelectionInfo? GetCurrentSelection()
    {
        try
        {
            return JsRuntime.Selection.GetSelectionAsync(_editorId).GetAwaiter().GetResult();
        }
        catch
        {
            return null;
        }
    }
    
    internal string? GetCurrentHtml() => _currentHtml;
    internal string? GetCurrentText() => null; // Would extract text from HTML

    internal async Task OpenPanelAsync(Type componentType, object? parameters = null)
    {
        if (_slideOutPanel != null)
        {
            await _slideOutPanel.OpenAsync(componentType, parameters);
        }
    }

    internal async Task ClosePanelAsync()
    {
        if (_slideOutPanel != null)
        {
            await _slideOutPanel.CloseAsync();
            
            // Update content after panel closes (panel may have inserted/modified content)
            await UpdateContentAsync();
            await UpdateStateAsync();
            StateHasChanged();
        }
    }

    internal async Task ToggleSourceViewAsync()
    {
        if (_isSourceView)
        {
            // Switching from source view to rich text view
            // Store the source content first
            var contentToRestore = _sourceViewContent;
            
            // Toggle the view flag first so the component re-renders to show the editor
            _isSourceView = false;
            _currentState.IsSourceView = false;
            StateHasChanged();
            
            // Wait a moment for the component to render
            await Task.Delay(50);
            
            // Re-setup the resize handle since DOM has changed
            await JSRuntime.InvokeVoidAsync("ZauberRTE.resize.setupResizeHandle", _editorId);
            
            // Now set the HTML content
            if (!string.IsNullOrEmpty(contentToRestore))
            {
                await JsRuntime.Mutation.SetHtmlAsync(_editorId, contentToRestore);
                _currentHtml = contentToRestore;
            }
        }
        else
        {
            // Switching from rich text view to source view
            _sourceViewContent = await JsRuntime.Mutation.GetHtmlAsync(_editorId);
            if (string.IsNullOrEmpty(_sourceViewContent))
            {
                _sourceViewContent = _currentHtml;
            }
            
            _isSourceView = true;
            _currentState.IsSourceView = true;
            StateHasChanged();
            
            // Wait a moment for the component to render
            await Task.Delay(50);
            
            // Re-setup the resize handle for the source view textarea
            await JSRuntime.InvokeVoidAsync("ZauberRTE.resize.setupResizeHandle", _editorId);
        }
        
        await UpdateStateAsync();
    }

    internal async Task ShowToastAsync(string message, ToastType type = ToastType.Info)
    {
        // Would show toast notification - placeholder implementation
        await Task.CompletedTask;
    }

    internal async Task FocusAsync()
    {
        await JsRuntime.Mutation.StartObservingAsync(_editorId); // Placeholder
    }

    [JSInvokable]
    public async Task OnContentModifiedAsync()
    {
        // Called from JavaScript when content is modified (e.g., Enter key, Tab, etc.)
        await UpdateContentAsync();
    }

    public void Dispose()
    {
        // Cleanup JS resources
        if (_isInitialized)
        {
            // JsRuntime.Mutation.StopObservingAsync(_editorId).Wait();
        }
    }
}

<script src="_content/ZauberCMS.RTE/js/lib/purify.min.js"></script>
<script src="_content/ZauberCMS.RTE/js/zauber-rte.js"></script>
